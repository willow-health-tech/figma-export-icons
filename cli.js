#!/usr/bin/env node

const defaults = require('./src/defaults')
const figma = require('./src/figma-client')
const fs = require('fs')
const path = require('path')
const ora = require('ora')
const chalk = require('chalk')
const ui = require('cliui')({ width: 80 })
const axios = require('axios')
const prompts = require('prompts')
const promptsList = require('./src/prompts')
const mkdirp = require('mkdirp')
const rimraf = require('rimraf')
const argv = require('minimist')(process.argv.slice(2))
let config = {}
let figmaClient
const spinner = ora()

const DIRS = {};

function cap(s) {
  if (typeof s !== 'string') return ''
  return s.charAt(0).toUpperCase() + s.slice(1)
}

function addToIndex({name, directory}) {
  console.log(name, directory);
  DIRS[directory] = DIRS[directory] || [];
  DIRS[directory].push(name)

  console.log(name, directory);
}

function writeIndexes() {
  const indexExt = config['indexExt'] || defaults['indexExt'];
  const all_dirs = Object.keys(DIRS);
  Object.entries(DIRS).map(([dir, svgs]) => {
    fs.writeFileSync(`${dir}/index.${indexExt}`, [
      "","/* autogenerated from figma-export-icons */",
      indexExt.endsWith('x') ? `import React from "react";` : "",
      ...svgs.map((name) => 
        indexExt.startsWith('ts') ? `export {default as ${cap(name)}} from './${name}.svg';` : 
          `exports['${cap(name)}'] = require('./${name}.svg');`
      ),
      // subdirs
      ...all_dirs.filter(d => (d !== dir) && d.startsWith(dir)).map(d => {
        const name = d.split('/').slice(-1)[0];
        return indexExt.startsWith('ts') ? 
        `export const ${cap(name)} = require('./${name}');`: 
        // `export * as ${cap(name)} from './${name}';` : 
        `exports['${cap(name)}'] = require('./${name}');`
      })
    ].join('\n'));
  })

  console.log('Index files written')
}


function deleteConfig () {
  const configFile = path.resolve(defaults.configFileName)
  if (fs.existsSync(configFile)) {
    fs.unlinkSync(configFile)
    console.log(chalk.cyan.bold('Deleted previous config'))
  }
}

function updateGitIgnore () {
  const ignorePath = '.gitignore'
  const configPath = argv.config || defaults.configFileName
  const ignoreCompletePath = path.resolve(ignorePath)
  if (fs.existsSync(configPath)) {
    const ignoreContent = `\n#figma-export-icons\n${configPath}`
    const ignore = fs.existsSync(ignoreCompletePath)
      ? fs.readFileSync(ignoreCompletePath, 'utf-8')
      : ''
    if(!ignore.includes(ignoreContent)) {
      fs.writeFileSync(ignoreCompletePath, ignore + ignoreContent)
      console.log(`Updated ${ignorePath} : ${ignoreContent}`)
    }
  }
}

function getConfig () {
  return new Promise((resolve) => {
    const configFile = path.resolve(argv.config || defaults.configFileName)
    if (fs.existsSync(configFile)) {
      config = JSON.parse(fs.readFileSync(configFile, 'utf-8'))
      const missingConfig = promptsList.filter((q) => !config[q.name])
      if (missingConfig.length > 0) getPromptData(missingConfig).then(() => resolve())
      else resolve()
    } else {
      getPromptData().then(() => resolve())
    }
  })
}

async function getPromptData ( list = promptsList ) {
  const onCancel = prompt => {
    process.exit(1)
  }
  const response = await prompts(list, { onCancel })
  config = Object.assign(config, response)
  fs.writeFileSync('icons-config.json', JSON.stringify(config, null, 2))
}

function createOutputDirectory () {
  return new Promise((resolve) => {
    const directory = path.resolve(config.iconsPath)
    if (!fs.existsSync(directory)) {
      console.log(`Directory ${config.iconsPath} does not exist`)
      if (mkdirp.sync(directory)) {
        console.log(`Created directory ${config.iconsPath}`)
        resolve()
      }
    } else {
      resolve()
    }
  })
}

function deleteIcon (iconPath) {
  return new Promise((resolve) => {
    fs.unlink(iconPath, (err) => {
      if (err) throw err
      // if no error, file has been deleted successfully
      resolve()
    })
  })
}

function deleteDirectory (directory) {
  return new Promise((resolve) => {
    fs.rmdir(directory, (err) => {
      if (err) throw err
      resolve()
    })
  })
}

function deleteIcons () {
  return new Promise((resolve) => {
    const directory = path.resolve(config.iconsPath)
    // read icons directory files
    fs.readdir(directory, (err, files) => {
      if (err) throw err
      spinner.start('Deleting directory contents')
      console.log('Deleting:', directory);
      setTimeout(() => {
        rimraf(directory, (err)=> {
          if (err) throw err;
          resolve();
        })
      }, 3000)

      // //TODO rimra
      // let filesToDelete = []
      // let subdirectories = []
      // files.forEach((file) => {
      //   const hasSubdirectory = fs.lstatSync(path.join(directory, file)).isDirectory()
      //   if (hasSubdirectory) {
      //     const subdirectory = path.join(directory, file)
      //     subdirectories.push(subdirectory)
      //     // read subdirectory
      //     fs.readdir(subdirectory, (err, files) => {
      //       if (err) throw err
      //       files.forEach(file => filesToDelete.push(deleteIcon(path.join(subdirectory, file))))
      //     })
      //   } else {
      //     if (file !== 'README.md') {
      //       filesToDelete.push(deleteIcon(path.join(directory, file)))
      //     }
      //   }
      // })
      // Promise.all(filesToDelete).then(() => {
      //   const directoriesToDelete = subdirectories.map(subdirectory => deleteDirectory(subdirectory))
      //   Promise.all(directoriesToDelete).then(() => {
      //     spinner.succeed()
      //     resolve()
      //   })
      // })
    })
  })
}

function findDuplicates (propertyName, arr) {
  return arr.reduce((acc, current) => {
    const x = acc.find(item => item[propertyName] === current[propertyName])
    if (x) {
      spinner.fail(chalk.bgRed.bold(`Duplicate icon name: ${x[propertyName]}. Please fix figma file`))
      current[propertyName] = current[propertyName] + '-duplicate-name'
    }
    return acc.concat([current])
  }, [])
}

function getFigmaFile () {
  return new Promise((resolve) => {
    spinner.start('Fetching Figma file (this might take a while depending on the figma file size)')
    figmaClient.get(`/files/${config.fileId}`)
      .then((res) => {
        const endTime = new Date().getTime()
        spinner.succeed()
        console.log(chalk.cyan.bold(`Finished in ${(endTime - res.config.startTime) / 1000}s\n`))
        const page = res.data.document.children.find(c => c.name === config.page)
        if (!page) {
          console.log(chalk.red.bold('Cannot find Icons Page, check your settings'))
          return
        }
        if (!page.children.find(c => c.name === config.frame)) {
          console.log(chalk.red.bold('Cannot find Icons Frame in this Page, check your settings'))
          return
        }
        let icons = page.children.find(c => c.name === config.frame).children.map((icon) => {
          return {id: icon.id, name: icon.name}
        })
        icons = findDuplicates('name', icons)
        resolve(icons)
      })
      .catch((err) => {
        spinner.fail()
        if (err.response) {
          console.log(chalk.red.bold(`Cannot get Figma file: ${err.response.data.status} ${err.response.data.err}`))
        } else {
          console.log(err)
        }
        process.exit(1)
      })
  })
}

function getImages (icons) {
  return new Promise((resolve) => {
    spinner.start('Fetching icon urls')
    const iconIds = icons.map(icon => icon.id).join(',')
    figmaClient.get(`/images/${config.fileId}?ids=${iconIds}&format=svg`)
      .then((res) => {
        spinner.succeed()
        const images = res.data.images
        icons.forEach((icon) => {
          icon.image = images[icon.id]
        })
        resolve(icons)
      })
      .catch((err) => {
        console.log('Cannot get icons: ', err)
        process.exit(1)
      })
  })
}

function downloadImage (url, name) {
  let nameClean = name
  let directory = config.iconsPath
  const idx = name.lastIndexOf('/')
  if (idx !== -1) {
    directory = directory + '/' + name.substring(0, idx)
    nameClean = name.substring(idx + 1)
    if (!fs.existsSync(directory)) {
      if (mkdirp.sync(directory)) {
        console.log(`\nCreated sub directory ${directory}`)
        iconPath = directory
      } else {
        console.log('Cannot create directories')
        process.exit(1)
      }
    }
  }
  const imagePath = path.resolve(directory, `${nameClean}.svg`)
  const writer = fs.createWriteStream(imagePath)
  addToIndex({name:nameClean, directory})

  axios.get(url, {responseType: 'stream'})
    .then((res) => {
      res.data.pipe(writer)
    })
    .catch((err) => {
      spinner.fail()
      console.log(name)
      console.log(err.message)
      console.log(err.config.url)
      console.log(chalk.red.bold('Something went wrong fetching the image from S3, please try again'),)
      process.exit(1)
    })

  return new Promise((resolve, reject) => {
    writer.on('finish', () => {
      // console.log(`Saved ${name}.svg`, fs.statSync(imagePath).size)
      resolve({
        name: `${name}.svg`,
        size: fs.statSync(imagePath).size
      })
    })
    writer.on('error', (err) => {
      console.log('error writting file', err)
      reject(err)
    })
  })

}

function makeRow (a, b) {
  return `  ${a}\t    ${b}\t`
}

function formatSize (size) {
  return (size / 1024).toFixed(2) + ' KiB'
}

function makeResultsTable (results) {
  ui.div(
    makeRow(
      chalk.cyan.bold(`File`),
      chalk.cyan.bold(`Size`),
    ) + `\n\n` +
    results.map(asset => makeRow(
      asset.name.includes('-duplicate-name')
        ? chalk.red.bold(asset.name)
        : chalk.green(asset.name),
      formatSize(asset.size)
    )).join(`\n`)
  )
  return ui.toString()
}

function exportIcons () {
  getFigmaFile()
    .then((res) => {
      getImages(res)
        .then((icons) => {
          console.log(`Api returned ${icons.length} icons\n`)
          createOutputDirectory()
          .then(() => {
            deleteIcons().then(() => {
              spinner.start('Downloading')
              const AllIcons = icons.map(icon => downloadImage(icon.image, icon.name))
              // const AllIcons = []
              Promise.all(AllIcons).then((res) => {
                spinner.succeed(chalk.cyan.bold('Download Finished!\n'));
                writeIndexes();
                console.log(`${makeResultsTable(res)}\n`)
              })
            })
          })
        })
        .catch((err) => {
          console.log(chalk.red(err))
        })
  })
}

function run () {
  if (argv.u) updateGitIgnore();
  if (argv.c) {
    deleteConfig()
  }
  getConfig().then(() => {
    figmaClient = figma(config.figmaPersonalToken)
    exportIcons()
  })
}

run()
